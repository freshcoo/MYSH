# MYSH

MYSH is a shell made by me which mimics and performs the same way as any other unix based terminal/shell.

The `mysh` shell processes user input through several key steps to execute commands, similar to Unix-based shells. When the user enters a line of input, the shell displays a prompt, determined by the `PROMPT` environment variable, and waits for the user to input a command. Upon receiving input, the shell first checks for the presence of pipe operators (`|`). If pipes are present, the input line is split into multiple commands using the `split_by_pipe_op()` function, which treats each command as a separate string.

If no pipes are found, the input is split into individual arguments using the `split_argument()` function, which leverages the `shlex.split()` method to respect quoted strings and handle special cases like escaped quotes. The first word in the split input is identified as the command. The shell then checks if this command matches any of the built-in commands stored in the `BUILT_IN_COMMANDS` dictionary. If it is a built-in command, the corresponding function is executed directly within the shell. For external commands, the shell searches the system's `PATH` for the executable. If found, the shell forks a new process using `os.fork()` and executes the command with `os.execvp()`. The shell waits for the command to complete using `os.waitpid()` before returning control to the user. It also handles signals like `SIGINT` (Ctrl+C) to ensure smooth operation and proper termination of processes.

`mysh` performs environment variable substitution by identifying variables in user input using the `${variable_name}` syntax. It uses regular expressions to detect these patterns and checks if the variables exist in the environment. If a valid variable is found, its value replaces `${variable_name}` in the output. If the valid variable is not found, the variable is replaced with an empty string. The shell also handles cases where the user wants to use the literal `${variable_name}` without substitution by allowing them to escape the `$` with a backslash, like `\${variable_name}`. In such cases, the shell recognizes the escape sequence, removes the backslash, and leaves the variable reference as a literal string in the input. This handling ensures that environment variables are substituted correctly unless explicitly escaped by the user, providing flexibility in command construction. 

Handling pipelines in `mysh` involves executing a sequence of commands where the output of one command is used as the input for the next. When the shell detects a pipe (`|`) in the input, it splits the command line into individual commands using the `split_by_pipe_op()` function. This function ensures that only unquoted pipes are treated as separators, preserving the integrity of quoted strings containing pipes.

The shell then creates a series of pipes using `os.pipe()` to facilitate data flow between commands. Each command in the pipeline is executed in a separate child process, created by `os.fork()`. The shell redirects the `stdout` of each command to the write end of the pipe and the `stdin` of the next command to the read end of the pipe using `os.dup2()`. This setup allows the output of one command to be directly fed into the next, forming a chain of processes. After executing the commands, the shell closes all unnecessary file descriptors and waits for all child processes to complete using `os.waitpid()`. This approach ensures that all commands in the pipeline run in parallel, with proper synchronization and error handling, enabling seamless data transfer between commands in a manner similar to traditional Unix shells. 

